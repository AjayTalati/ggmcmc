#' Manage the output from a coda object to be plotted by ggmcmc and convert it in an object that ggplot understands
#'
#' @param S either mcmc.list object with samples from JAGS, mcmc object with samples from MCMCpack, stanfit object with samples from rstan, or a list with the filenames of csv files generated by stan outside rstan (where the order of the files is assumed to be the order of the chains). ggmcmc guesses what is the original object and tries to import it accordingly.
#' @param burnin Logical or numerical value. When logical and true, the number of samples in the burnin period will be taken into account, if it can be guessed by the extracting process. Otherwise, iterations will start counting from 1. Defaults to false. If a numerical vector is given, the user then supplies the length of the burnin period. Not yet implemented.
#' @param inc_warmup logical. When dealing with stanfit objects from rstan, logical value whether the warmup samples are included. Defaults to false.
#' @param stan_include_auxiliar. Logical to include "lp__" parameter in rstan, and "lp__", "treedepth__" and "stepsize__" in stan running without rstan. Defaults to false.
#' @param parallel logical value for using parallel computing when managing the data frame in other functions
#' @export
#' @return D data frame with the data arranged and ready to be used by the rest of the ggmcmc functions. The dataframe has four columns, namely: Iteration, Parameter, value and Chain, and four attributes: nChains, nParameters, nIterations, parallel.
#' @examples
#' # Assign 'D' to be a data frame suitable for ggmcmc functions from 
#' # a coda object called S
#' data(samples)
#' D <- ggs(S)        # S is a coda object
ggs <- function(S, burnin=FALSE, inc_warmup=FALSE, stan_include_auxiliar=FALSE, parallel=TRUE) {
  #
  # Manage stanfit obcjets
  # Manage stan output first because it is firstly converted into an mcmc.list
  #
  if (class(S)=="stanfit") { 
    S <- rstan::extract(S, inc_warmup=inc_warmup)
    S <- do.call(mcmc.list, alply(S, 2, coda::mcmc))
    # Exclude, by default, lp parameter
    if (!stan_include_auxiliar) {
      S <- S[,1:(dim(S[[1]])[2]-1)] # delete the last column, the last parameter, which is lp__
    }
  }
  #
  # Manage csv files than contain stan samples
  # Also converted first to an mcmc.list
  #
  if (class(S)=="list") {
    S.out <- coda::mcmc.list()
    for (i in 1:length(S)) {
      S.out[[i]] <- coda::mcmc(
        read.table(S[[i]], sep=",", header=TRUE, colClasses="numeric"))
    }
    S <- S.out
    # Exclude, by default, lp parameter
    if (!stan_include_auxiliar) {
      S <- S[,-c(1:3)] # delete the last column, the last parameter, which is lp__
    }
  }
  #
  # Manage mcmc.list and mcmc objects
  #
  if (class(S)=="mcmc.list" | class(S)=="mcmc") {  # JAGS typical output or MCMCpack
    lS <- length(S)
    D <- NULL
    if (lS == 1 | class(S)=="mcmc") { # Single chain or MCMCpack
      if (lS == 1 & class(S)=="mcmc.list") { # single chain
        s <- S[[1]]
      } else { # MCMCpack
        s <- S
      }
      # Process a single chain
      D <- cbind(ggs_chain(s), Chain=1)
      # Get information from mcpar (burnin period, thinning)
      nBurnin <- (attributes(s)$mcpar[1])-(1*attributes(s)$mcpar[3])
      nThin <- attributes(s)$mcpar[3]
    } else {
      # Process multiple chains
      for (l in 1:lS) {
        s <- S[l][[1]]
        D <- rbind(D, cbind(ggs_chain(s), Chain=l))
      }
      # Get information from mcpar (burnin period, thinning). Taking the last
      # chain is fine. All chains are assumed to have the same structure.
      nBurnin <- (attributes(s)$mcpar[1])-(1*attributes(s)$mcpar[3])
      nThin <- attributes(s)$mcpar[3]
    }
    # Set several attributes to the object, to avoid computations afterwards
    # Number of chains
    attr(D, "nChains") <- lS
    # Number of parameters
    attr(D, "nParameters") <- length(unique(D$Parameter))
    # Number of Iterations really present in the sample
    attr(D, "nIterations") <- max(D$Iteration)
    # Number of burning periods previously
    attr(D, "nBurnin") <- nBurnin
    # Thinning interval
    attr(D, "nThin") <- nThin
    # Whether parallel computing is desired
    attr(D, "parallel") <- parallel
    return(D)
  } else {
    stop("ggs is not able to transform the input object into a ggs object suitable for ggmcmc.")
  }
}

#' Manage each chain
#'
#' @param s a single chain to convert into a data frame
#' @return D data frame with the chain arranged
ggs_chain <- function(s) {
  # Get the names of the chains, the number of samples and the vector of
  # iterations
  name.chains <- dimnames(s)[[2]]
  n.samples <- dim(s)[1]
  iter <- 1:n.samples

  # Prepare the dataframe
  d <- data.frame(Iteration=iter, as.matrix(unclass(s)))
  D <- melt(d, id.vars=c("Iteration"), variable_name="Parameter")

  # Revert the name of the parameters to their original names
  levels(D$Parameter) <- name.chains

  # Return the modified data frame
  return(D)
}
